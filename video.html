<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Video Generator</title>
    <style>
        :root {
            --primary: #6366f1;
            --bg: #f8fafc;
            --surface: #ffffff;
            --text: #1e293b;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 { margin-bottom: 2rem; }

        .container {
            background: var(--surface);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 600px;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #475569;
        }

        input[type="file"],
        input[type="number"],
        select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            box-sizing: border-box; 
            font-size: 1rem;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 1rem;
            width: 100%;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button:hover { opacity: 0.9; }
        button:disabled { background-color: #cbd5e1; cursor: not-allowed; }

        /* Preview Area */
        .preview-area {
            margin-top: 2rem;
            text-align: center;
            display: none; /* Hidden by default */
        }

        video {
            max-width: 100%;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            margin-top: 1rem;
            max-height: 400px;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #e2e8f0;
            border-radius: 5px;
            margin-top: 1rem;
            overflow: hidden;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.2s linear;
        }

        .status-text {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: #64748b;
        }

        /* Hidden Canvas for processing */
        canvas { display: none; }
    </style>
</head>
<body>

    <h1>Flashcard Video Maker</h1>

    <div class="container">
        <div class="form-group">
            <label for="imageInput">1. Upload Flashcards (PNG/JPG)</label>
            <input type="file" id="imageInput" multiple accept="image/*">
            <small style="color: #64748b">Images will appear in the order selected.</small>
        </div>

        <div class="settings-grid">
            <div class="form-group">
                <label for="duration">Duration per Slide (sec)</label>
                <input type="number" id="duration" value="3" min="1" step="0.5">
            </div>

            <div class="form-group">
                <label for="format">Video Format</label>
                <select id="format">
                    <option value="feed">Instagram Feed (1080x1080)</option>
                    <option value="story">Story / Reels (1080x1920)</option>
                    <option value="youtube">YouTube (1920x1080)</option>
                </select>
            </div>
        </div>

        <div class="form-group">
            <label for="audioInput">4. Background Music (Optional)</label>
            <input type="file" id="audioInput" accept="audio/*">
        </div>

        <button id="generateBtn" onclick="startGeneration()">Generate Video</button>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="status-text" id="statusText"></div>

        <div class="preview-area" id="resultArea">
            <h3>Your Video is Ready!</h3>
            <video id="outputVideo" controls></video>
            <br><br>
            <a id="downloadLink" href="#" download="flashcards.webm">
                <button style="background-color: #10b981;">Download Video</button>
            </a>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let audioCtx, audioBuffer, sourceNode, destNode;

        // Dimensions dictionary
        const dimensions = {
            feed: { w: 1080, h: 1080 },
            story: { w: 1080, h: 1920 },
            youtube: { w: 1920, h: 1080 }
        };

        async function startGeneration() {
            const imageInput = document.getElementById('imageInput');
            const audioInput = document.getElementById('audioInput');
            const durationInput = document.getElementById('duration');
            const formatInput = document.getElementById('format');
            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('statusText');
            const progressFill = document.getElementById('progressFill');
            const progressBar = document.getElementById('progressBar');
            const resultArea = document.getElementById('resultArea');

            // Validation
            if (imageInput.files.length === 0) {
                alert("Please select at least one image.");
                return;
            }

            // UI Reset
            btn.disabled = true;
            resultArea.style.display = 'none';
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            
            // 1. Setup Canvas Size
            const selectedDim = dimensions[formatInput.value];
            canvas.width = selectedDim.w;
            canvas.height = selectedDim.h;

            // 2. Load Images
            status.innerText = "Loading images...";
            const images = [];
            for (let file of imageInput.files) {
                const img = await loadImage(file);
                images.push(img);
            }

            // 3. Setup Audio (if present)
            let audioStream = null;
            if (audioInput.files.length > 0) {
                status.innerText = "Processing audio...";
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const arrayBuffer = await audioInput.files[0].arrayBuffer();
                    audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                    
                    // Create a destination to mix into the recorder
                    destNode = audioCtx.createMediaStreamDestination();
                    audioStream = destNode.stream;
                } catch (e) {
                    console.error("Audio error:", e);
                    alert("Error loading audio file. Proceeding without audio.");
                }
            }

            // 4. Setup Recorder
            const fps = 30;
            const slideDuration = parseFloat(durationInput.value);
            const totalDuration = images.length * slideDuration; // Total seconds
            
            // Combine canvas stream and audio stream (if any)
            const canvasStream = canvas.captureStream(fps);
            let finalStream = new MediaStream();
            
            // Add video tracks
            canvasStream.getVideoTracks().forEach(track => finalStream.addTrack(track));
            
            // Add audio tracks if available
            if (audioStream) {
                audioStream.getAudioTracks().forEach(track => finalStream.addTrack(track));
            }

            const mediaRecorder = new MediaRecorder(finalStream, {
                mimeType: 'video/webm;codecs=vp9' // Standard web format
            });

            const chunks = [];
            mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                
                const videoOutput = document.getElementById('outputVideo');
                const downloadLink = document.getElementById('downloadLink');
                
                videoOutput.src = url;
                downloadLink.href = url;
                downloadLink.download = `flashcards_${formatInput.value}.webm`; // WebM is safest for browser generation
                
                resultArea.style.display = 'block';
                status.innerText = "Done!";
                btn.disabled = false;
                
                // Cleanup Audio Context
                if(audioCtx) audioCtx.close();
            };

            // 5. Start Recording & Animation Loop
            mediaRecorder.start();
            status.innerText = "Recording video... (Please wait)";
            
            // Start playing audio if it exists
            if (audioBuffer && audioCtx) {
                playAudioLoop(audioBuffer, audioCtx, destNode, totalDuration);
            }

            const startTime = Date.now();
            let currentImageIndex = 0;

            function draw() {
                const elapsed = (Date.now() - startTime) / 1000;
                
                // Calculate progress
                const progress = Math.min((elapsed / totalDuration) * 100, 100);
                progressFill.style.width = `${progress}%`;
                status.innerText = `Rendering: ${Math.round(progress)}%`;

                // Determine which image to show
                currentImageIndex = Math.floor(elapsed / slideDuration);

                if (currentImageIndex < images.length) {
                    // Clear canvas with black background
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Draw Image (Contain / Fit logic)
                    const img = images[currentImageIndex];
                    drawImageContain(ctx, img, canvas.width, canvas.height);

                    requestAnimationFrame(draw);
                } else {
                    // Finished
                    mediaRecorder.stop();
                }
            }

            draw();
        }

        // Helper: Load Image from File
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(file);
            });
        }

        // Helper: Draw image "contain" style (fit within canvas)
        function drawImageContain(ctx, img, targetW, targetH) {
            const imgRatio = img.width / img.height;
            const targetRatio = targetW / targetH;
            
            let drawW, drawH;

            if (imgRatio > targetRatio) {
                // Image is wider than canvas
                drawW = targetW;
                drawH = targetW / imgRatio;
            } else {
                // Image is taller than canvas
                drawW = targetH * imgRatio;
                drawH = targetH;
            }

            const x = (targetW - drawW) / 2;
            const y = (targetH - drawH) / 2;

            ctx.drawImage(img, x, y, drawW, drawH);
        }

        // Helper: Loop Audio
        function playAudioLoop(buffer, ctx, destination, duration) {
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            source.loop = true; // Loop the audio
            source.connect(destination);
            source.start(0);
            
            // Stop audio when video ends
            setTimeout(() => {
                source.stop();
            }, duration * 1000);
        }

    </script>
</body>
</html>
