<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>eptOnline Video Studio â€” Fixed</title>
  <style>
    :root {
      --primary: #f97316;
      --bg: #fff7ed;
      --surface: #ffffff;
      --text: #1e293b;
      --muted: #64748b;
    }
    body {
      margin: 0;
      padding: 20px;
      font-family: "Segoe UI", Roboto, system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      display:flex;
      justify-content:center;
    }
    .wrapper {
      width: 100%;
      max-width: 1100px;
    }
    h1 {
      margin: 0 0 18px 0;
      color: #c2410c;
      font-size: 1.5rem;
    }
    .container {
      background: var(--surface);
      padding: 18px;
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
      display: grid;
      grid-template-columns: 1fr 420px;
      gap: 18px;
    }
    @media (max-width: 980px) {
      .container { grid-template-columns: 1fr; }
    }

    .panel { display:flex; flex-direction:column; gap:12px; }

    label { font-weight:700; color:#431407; font-size:0.9rem; margin-bottom:6px; display:block; }
    input[type="file"], select, input[type="text"], input[type="number"], textarea {
      width:100%;
      padding:10px;
      border-radius:8px;
      border:1px solid #f3c27a;
      box-sizing:border-box;
      font-family:inherit;
    }
    .input-row { display:flex; gap:8px; align-items:center; }
    .small { width:120px; }

    .playlist {
      border:1px solid #e6eef6;
      border-radius:8px;
      min-height:220px;
      max-height:420px;
      overflow:auto;
      padding:8px;
      background:#fff;
    }

    .plist-item {
      display:flex;
      gap:10px;
      align-items:center;
      padding:8px;
      border-radius:6px;
      margin-bottom:6px;
      background:#fbf6f2;
      cursor:grab;
    }
    .plist-item.dragging { opacity:0.6; transform:scale(0.995); cursor:grabbing; }
    .plist-thumb { width:72px; height:72px; object-fit:cover; border-radius:6px; flex-shrink:0; border:1px solid #eee; }
    .plist-meta { flex:1; display:flex; flex-direction:column; gap:6px; }
    .plist-actions { display:flex; flex-direction:column; gap:6px; align-items:flex-end; }

    .btn { border:none; border-radius:8px; padding:10px 14px; cursor:pointer; font-weight:700; }
    .btn-primary { background:var(--primary); color:white; }
    .btn-secondary { background:#3b82f6; color:white; }
    .btn-ghost { background:transparent; color:var(--muted); border:1px solid #e6eef6; }

    .caption-area { background:#f1f5f9; padding:12px; border-radius:8px; border:1px solid #cbd5e1; }

    .preview { text-align:center; padding-top:12px; border-top:1px dashed #fdba74; display:none; }
    video { max-width:100%; border-radius:8px; border:3px solid #000; display:block; margin:12px auto; }

    .status { display:flex; gap:8px; align-items:center; flex-direction:column; }
    .progress-outer { width:100%; background:#e6eef6; height:12px; border-radius:999px; overflow:hidden; }
    .progress-fill { width:0%; height:100%; background:var(--primary); transition:width 0.1s linear; }

    .small-note { font-size:0.85rem; color:var(--muted); }

    .options { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    .flex-between { display:flex; justify-content:space-between; align-items:center; gap:8px; }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>eptOnline Video Studio â€” Updated</h1>
    <div class="container">
      <div class="panel">
        <!-- Settings -->
        <div style="display:flex;flex-direction:column;gap:10px;">
          <div>
            <label>Download Preset / Format</label>
            <select id="downloadPreset">
              <option value="instagram_post">Instagram Post (1080Ã—1080)</option>
              <option value="instagram_reel">Instagram Reel / Story (1080Ã—1920)</option>
              <option value="tiktok_reel">TikTok Reel (1080Ã—1920)</option>
              <option value="facebook_reel">Facebook Reel (1080Ã—1920)</option>
              <option value="youtube_landscape">YouTube Landscape (1920Ã—1080)</option>
              <option value="facebook_landscape">Facebook Video (1280Ã—720)</option>
              <option value="youtube_reel">YouTube Short (1080Ã—1920)</option>
            </select>
            <div class="small-note">Selecting a preset updates canvas size & framing rules automatically.</div>
          </div>

          <div style="display:flex; gap:10px;">
            <div style="flex:1;">
              <label>Background Color</label>
              <input type="color" id="bgColor" value="#c76e08" />
            </div>
            <div style="width:140px;">
              <label>Frames / Sec (default)</label>
              <input type="number" id="defaultDuration" min="1" value="3" />
            </div>
          </div>

          <div style="display:flex; gap:10px; align-items:center;">
            <label style="margin:0;">
              <input type="checkbox" id="addIntro" checked /> Add Intro
            </label>
            <label style="margin:0;">
              <input type="checkbox" id="addOutro" checked /> Add Outro
            </label>
            <label style="margin:0;">
              <input type="checkbox" id="autoConvertMp4" /> Auto-convert to MP4 (ffmpeg.wasm)
            </label>
          </div>

          <div style="display:flex; gap:10px; align-items:center;">
            <div style="flex:1;">
              <label>Intro Duration (secs)</label>
              <input type="number" id="introDuration" min="1" value="2" />
            </div>
            <div style="width:140px;">
              <label>Outro Duration (secs)</label>
              <input type="number" id="outroDuration" min="1" value="3" />
            </div>
          </div>

          <div>
            <label>Background Music</label>
            <select id="musicSelect">
              <option value="none">No Music</option>
              <option value="track1">Track 1 (local)</option>
              <option value="track2">Track 2 (local)</option>
            </select>
            <div class="small-note">If using local sample tracks, set MUSIC_TRACKS constants.</div>
          </div>
        </div>

        <!-- Upload + Playlist -->
        <div>
          <label>Upload Images (drag & drop supported)</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <input type="file" id="imageInput" accept="image/*" multiple />
            <button class="btn btn-secondary" id="btnAddFromUrl">Add via URL</button>
          </div>
          <div class="small-note">You can drag thumbnails to reorder them. Remove items using the trash icon.</div>

          <div class="playlist" id="playlist"></div>
        </div>

        <!-- Caption -->
        <div class="caption-area">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <label style="margin:0;">Social Media Caption Generator</label>
            <div style="display:flex; gap:8px;">
              <button class="btn btn-ghost" id="btnGenerateCaption">Generate & Copy</button>
            </div>
          </div>
          <textarea id="captionBox" placeholder="Caption will appear here..." rows="4"></textarea>
        </div>

      </div>

      <!-- Right column: controls, preview, status -->
      <div class="panel">
        <div style="display:flex; flex-direction:column; gap:8px;">
          <div class="flex-between">
            <div>
              <label>Filename Prefix</label>
              <input type="text" id="filenamePrefix" placeholder="eptonline_video" />
            </div>
            <div style="width:200px;">
              <label>Target Platform (download)</label>
              <select id="downloadSelect">
                <option value="instagram_post">Instagram Post (1080Ã—1080)</option>
                <option value="instagram_reel">Instagram Reel (1080Ã—1920)</option>
                <option value="tiktok_reel">TikTok Reel (1080Ã—1920)</option>
                <option value="facebook_reel">Facebook Reel (1080Ã—1920)</option>
                <option value="youtube_landscape">YouTube Landscape (1920Ã—1080)</option>
                <option value="facebook_landscape">Facebook Video (1280Ã—720)</option>
                <option value="youtube_reel">YouTube Short (1080Ã—1920)</option>
              </select>
            </div>
          </div>

          <div style="display:flex; gap:8px;">
            <button class="btn btn-primary" id="btnGenerate">Generate Video</button>
            <button class="btn btn-ghost" id="btnPreviewCanvas">Preview Current Frame</button>
            <button class="btn btn-ghost" id="btnClear">Clear All</button>
          </div>

          <div class="status">
            <div class="progress-outer"><div class="progress-fill" id="progressFill"></div></div>
            <div id="statusText" class="small-note"></div>
          </div>

          <div class="preview" id="previewPanel">
            <h3 style="margin:6px 0 0 0;">Video Ready</h3>
            <video id="outputVideo" controls playsinline></video>
            <div style="display:flex;gap:8px; justify-content:center; margin-top:8px;">
              <a id="downloadLink" href="#" download><button class="btn btn-primary">Download</button></a>
              <button class="btn btn-secondary" id="btnConvertIfNeeded">Convert to MP4 (manual)</button>
            </div>
            <div id="postChecks" style="margin-top:8px;"></div>
          </div>
        </div>

        <!-- Hidden canvas used to render frames -->
        <canvas id="canvas" style="display:none;"></canvas>
      </div>
    </div>
  </div>

<script>
/*
  eptOnline Video Studio â€” revised script
  - Drag-and-drop reorder
  - Multiple format presets and download options
  - Intro / Outro per-format handling
  - Pre-generation validation and post-generation checks
  - Optional client-side MP4 conversion using ffmpeg.wasm (if enabled)
*/

/* ============ Configuration ============ */
const SOCIAL_HANDLES = {
  fb: "eptonline.org",
  ig: "@eptonline_org",
  yt: "eptonlineOrg",
  tiktok: "@eptonline.org"
};

const WEBSITE_URL = "https://eptonline.org";
const ICONS = {
  fb: 'https://cdn-icons-png.flaticon.com/512/5968/5968764.png',
  ig: 'https://cdn-icons-png.flaticon.com/512/3955/3955024.png',
  yt: 'https://cdn-icons-png.flaticon.com/512/3670/3670147.png',
  tiktok: 'https://cdn-icons-png.flaticon.com/512/3046/3046121.png'
};
// Provide valid URLs for the music files if you want music.
const MUSIC_TRACKS = {
  track1: 'path/to/music1.mp3',
  track2: 'path/to/music2.mp3'
};

/* ============ State ============ */
let playlist = []; // { id, file (File|ImageURL string), thumbnailURL, duration }
let dragSrcIndex = null;
let assets = { logo: null, icons: {}, slides: [] };
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

/* ============ Utility helpers ============ */
function uid(prefix='id') { return prefix + '_' + Math.random().toString(36).slice(2,9); }
function nowTimestamp() {
  const d = new Date();
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}_${String(d.getHours()).padStart(2,'0')}-${String(d.getMinutes()).padStart(2,'0')}-${String(d.getSeconds()).padStart(2,'0')}`;
}

/* ============ DOM refs ============ */
const playlistEl = document.getElementById('playlist');
const imageInput = document.getElementById('imageInput');
const btnGenerate = document.getElementById('btnGenerate');
const progressFill = document.getElementById('progressFill');
const statusText = document.getElementById('statusText');
const previewPanel = document.getElementById('previewPanel');
const outputVideo = document.getElementById('outputVideo');
const downloadLink = document.getElementById('downloadLink');
const btnConvertIfNeeded = document.getElementById('btnConvertIfNeeded');

/* ============ Playlist UI & Drag/Drop ============ */

imageInput.addEventListener('change', (ev) => {
  const files = Array.from(ev.target.files || []);
  addFilesToPlaylist(files);
});

document.getElementById('btnAddFromUrl').addEventListener('click', () => {
  const url = prompt('Enter image URL (direct image link):');
  if (url) addImageUrlToPlaylist(url);
});

function addFilesToPlaylist(files) {
  for (const f of files) {
    const id = uid('slide');
    const url = URL.createObjectURL(f);
    playlist.push({ id, file: f, thumbnailURL: url, duration: parseFloat(document.getElementById('defaultDuration').value || 3) });
  }
  renderPlaylist();
}

function addImageUrlToPlaylist(url) {
  const id = uid('slide');
  playlist.push({ id, file: url, thumbnailURL: url, duration: parseFloat(document.getElementById('defaultDuration').value || 3) });
  renderPlaylist();
}

function renderPlaylist() {
  playlistEl.innerHTML = '';
  if (playlist.length === 0) {
    playlistEl.innerHTML = '<p style="text-align:center;color:#999;margin:20px 0;">Upload images to see them here.</p>';
    return;
  }

  playlist.forEach((item, index) => {
    const div = document.createElement('div');
    div.className = 'plist-item';
    div.setAttribute('draggable', 'true');
    div.dataset.index = index;

    // drag handlers
    div.addEventListener('dragstart', (e) => {
      dragSrcIndex = index;
      div.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });
    div.addEventListener('dragend', () => {
      dragSrcIndex = null;
      document.querySelectorAll('.plist-item').forEach(n => n.classList.remove('dragging'));
    });
    div.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    });
    div.addEventListener('drop', (e) => {
      e.preventDefault();
      const targetIndex = Number(div.dataset.index);
      if (dragSrcIndex !== null && dragSrcIndex !== targetIndex) {
        reorderPlaylist(dragSrcIndex, targetIndex);
      }
    });

    const thumb = document.createElement('img');
    thumb.className = 'plist-thumb';
    thumb.src = item.thumbnailURL;
    thumb.alt = 'thumb';

    const meta = document.createElement('div');
    meta.className = 'plist-meta';

    const name = document.createElement('div');
    name.textContent = (typeof item.file === 'string') ? (item.file).slice(0,40) : (item.file.name || 'image');
    name.style.fontWeight = '700';
    name.style.fontSize = '0.95rem';

    const durRow = document.createElement('div');
    durRow.style.display='flex';
    durRow.style.gap='8px';
    durRow.style.alignItems='center';

    const durInput = document.createElement('input');
    durInput.type = 'number';
    durInput.min = '1';
    durInput.step = '0.5';
    durInput.value = item.duration;
    durInput.style.width = '100px';
    durInput.addEventListener('input', (e) => {
      const v = parseFloat(e.target.value) || 1;
      playlist[index].duration = v;
    });

    durRow.appendChild(durInput);
    durRow.appendChild(document.createElement('div')).textContent = 'secs';

    meta.appendChild(name);
    meta.appendChild(durRow);

    const actions = document.createElement('div');
    actions.className = 'plist-actions';

    const upBtn = document.createElement('button');
    upBtn.className = 'btn btn-ghost';
    upBtn.title = 'Move up';
    upBtn.innerHTML = 'â–²';
    upBtn.addEventListener('click', () => {
      if (index > 0) reorderPlaylist(index, index-1);
    });

    const downBtn = document.createElement('button');
    downBtn.className = 'btn btn-ghost';
    downBtn.title = 'Move down';
    downBtn.innerHTML = 'â–¼';
    downBtn.addEventListener('click', () => {
      if (index < playlist.length-1) reorderPlaylist(index, index+1);
    });

    const removeBtn = document.createElement('button');
    removeBtn.className = 'btn btn-ghost';
    removeBtn.title = 'Remove';
    removeBtn.innerHTML = 'ðŸ—‘';
    removeBtn.addEventListener('click', () => {
      URL.revokeObjectURL(item.thumbnailURL);
      playlist.splice(index, 1);
      renderPlaylist();
    });

    actions.appendChild(upBtn);
    actions.appendChild(downBtn);
    actions.appendChild(removeBtn);

    div.appendChild(thumb);
    div.appendChild(meta);
    div.appendChild(actions);

    playlistEl.appendChild(div);
  });
}

function reorderPlaylist(fromIndex, toIndex) {
  const item = playlist.splice(fromIndex,1)[0];
  playlist.splice(toIndex,0,item);
  renderPlaylist();
}

/* ============ Caption generator ============ */
document.getElementById('btnGenerateCaption').addEventListener('click', () => {
  const handleLines = [];
  if (SOCIAL_HANDLES.fb) handleLines.push(`Facebook: ${SOCIAL_HANDLES.fb}`);
  if (SOCIAL_HANDLES.ig) handleLines.push(`Instagram: ${SOCIAL_HANDLES.ig}`);
  if (SOCIAL_HANDLES.tiktok) handleLines.push(`TikTok: ${SOCIAL_HANDLES.tiktok}`);
  if (SOCIAL_HANDLES.yt) handleLines.push(`YouTube: ${SOCIAL_HANDLES.yt}`);
  const caption = [
    "Check out our latest learning resources!",
    `Visit: ${WEBSITE_URL}`,
    ...handleLines,
    "#Education #EptOnline #Learning"
  ].join("\n");
  const box = document.getElementById('captionBox');
  box.value = caption;
  navigator.clipboard?.writeText(caption).then(() => {
    alert('Caption copied to clipboard.');
  }).catch(()=>{ alert('Caption generated. Copy manually.'); });
});

/* ============ Pre-generation validation ============ */

function validateBeforeGeneration(formatDims, totalExpectedDuration) {
  const errors = [];
  if (playlist.length === 0) errors.push("No slides uploaded.");
  let totalDur = 0;
  for (const item of playlist) {
    if (!item.duration || item.duration < 1) errors.push("One or more slides have invalid duration.");
    totalDur += Number(item.duration || 0);
  }
  if (!isFinite(totalExpectedDuration) || totalExpectedDuration < 1) errors.push("Computed final duration invalid.");

  // Check music selection if chosen
  const musicSel = document.getElementById('musicSelect').value;
  if (musicSel !== 'none' && !MUSIC_TRACKS[musicSel]) {
    errors.push("Selected music track is configured but file path is not set in the script (MUSIC_TRACKS).");
  }

  return { ok: errors.length === 0, errors, totalDur };
}

/* ============ Asset loader (images & icons) ============ */
async function loadImageFromSource(src) {
  // Accept File, Blob, or URL string
  return new Promise((resolve) => {
    if (!src) return resolve(null);
    if (src instanceof File || src instanceof Blob) {
      const url = URL.createObjectURL(src);
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        URL.revokeObjectURL(url);
        resolve(img);
      };
      img.onerror = () => { URL.revokeObjectURL(url); resolve(null); };
      img.src = url;
    } else if (typeof src === 'string') {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    } else {
      resolve(null);
    }
  });
}

/* ============ Rendering primitives ============ */

function setCanvasSizeForPreset(preset) {
  // Map preset to dims & recommended fps
  const map = {
    instagram_post: { w:1080, h:1080, fps:30 },
    instagram_reel: { w:1080, h:1920, fps:30 },
    tiktok_reel: { w:1080, h:1920, fps:30 },
    facebook_reel: { w:1080, h:1920, fps:30 },
    youtube_landscape: { w:1920, h:1080, fps:30 },
    facebook_landscape: { w:1280, h:720, fps:30 },
    youtube_reel: { w:1080, h:1920, fps:30 }
  };
  return map[preset] || map.instagram_post;
}

function drawImageCover(ctx, img, w, h) {
  // Cover the canvas with the source while preserving aspect ratio
  const iw = img.width, ih = img.height;
  const ir = iw / ih;
  const tr = w / h;
  let drawW, drawH;
  if (ir > tr) {
    // image is wider than target
    drawH = h;
    drawW = h * ir;
  } else {
    drawW = w;
    drawH = w / ir;
  }
  const x = (w - drawW) / 2;
  const y = (h - drawH) / 2;
  ctx.drawImage(img, x, y, drawW, drawH);
}

function drawLogoTopRight(ctx, w, h, img, scale=0.14) {
  if (!img) return;
  const size = Math.round(w * scale);
  const pad = Math.round(w * 0.02);
  ctx.drawImage(img, w - size - pad, pad, size, size);
}

function drawFooterSocialBar(ctx, w, h, format) {
  const barH = Math.round(w * (format==='youtube_landscape' ? 0.08 : 0.10));
  const y = h - barH;
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.fillRect(0, y, w, barH);

  // simple centered text
  ctx.fillStyle = 'white';
  ctx.textBaseline = 'middle';
  const fontSize = Math.max(12, Math.round(barH * 0.4));
  ctx.font = `bold ${fontSize}px Arial`;
  const text = `${SOCIAL_HANDLES.ig||''}  ${WEBSITE_URL}`;
  ctx.textAlign = 'center';
  ctx.fillText(text, w/2, y + barH/2);
}

function renderIntroFrame(ctx, w, h, preset) {
  // Intro content adapted to the preset aspect ratio
  ctx.fillStyle = document.getElementById('bgColor').value || '#000';
  ctx.fillRect(0,0,w,h);
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  const big = Math.round(w * 0.09);
  ctx.font = `bold ${big}px Arial`;
  ctx.fillText('Welcome to EptOnline', w/2, h*0.42);

  // small subtitle
  ctx.font = `${Math.round(w*0.04)}px Arial`;
  ctx.fillText('Learn â€¢ Grow â€¢ Succeed', w/2, h*0.52);

  // logo if loaded
  if (assets.logo) {
    drawLogoTopRight(ctx, w, h, assets.logo, 0.20);
  }
}

function renderOutroFrame(ctx, w, h, preset) {
  ctx.fillStyle = document.getElementById('bgColor').value || '#000';
  ctx.fillRect(0,0,w,h);
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.font = `bold ${Math.round(w*0.06)}px Arial`;
  ctx.fillText('Thank you for watching!', w/2, h*0.45);
  ctx.font = `${Math.round(w*0.035)}px Arial`;
  ctx.fillText(WEBSITE_URL, w/2, h*0.55);
  drawFooterSocialBar(ctx, w, h, preset);
}

/* ============ Generation core ============ */

async function startGenerationFlow() {
  if (playlist.length === 0) {
    return alert('Please upload at least one image before generating.');
  }

  // Determine preset
  const preset = document.getElementById('downloadSelect').value;
  const dims = setCanvasSizeForPreset(preset);
  canvas.width = dims.w;
  canvas.height = dims.h;
  const fps = dims.fps || 30;

  // Build timeline: intro (optional) + slides + outro (optional)
  const addIntro = !!document.getElementById('addIntro').checked;
  const addOutro = !!document.getElementById('addOutro').checked;
  const introDur = Math.max(1, Number(document.getElementById('introDuration').value || 2));
  const outroDur = Math.max(1, Number(document.getElementById('outroDuration').value || 3));

  // Pre-validation
  let slidesTotalTime = playlist.reduce((s,i)=>s + Number(i.duration||0),0);
  const expectedTotal = (addIntro ? introDur : 0) + slidesTotalTime + (addOutro ? outroDur:0);
  const validation = validateBeforeGeneration(dims, expectedTotal);
  if (!validation.ok) {
    const proceed = confirm('Validation found issues:\n\n' + validation.errors.join('\n') + '\n\nProceed anyway?');
    if (!proceed) return;
  }

  try {
    statusText.innerText = 'Loading assets (icons / images)...';
    progressFill.style.width = '2%';
    // load logo & icons
    assets.logo = await loadImageFromSource(ICONS.yt) || null;
    assets.icons.fb = await loadImageFromSource(ICONS.fb);
    assets.icons.ig = await loadImageFromSource(ICONS.ig);
    assets.icons.yt = await loadImageFromSource(ICONS.yt);
    assets.icons.tiktok = await loadImageFromSource(ICONS.tiktok);

    // load slides
    assets.slides = [];
    for (const item of playlist) {
      statusText.innerText = `Loading image ${playlist.indexOf(item)+1} / ${playlist.length}...`;
      const img = await loadImageFromSource(item.file);
      if (!img) {
        console.warn('Failed to load image', item);
        continue;
      }
      assets.slides.push({img, duration: Number(item.duration)});
    }
    if (assets.slides.length === 0) {
      alert('No loadable images found. Aborting.');
      return;
    }

    // AUDIO: attempt to set up music if selected
    let audioStream = null;
    let audioCtx, audioSourceNode;
    const musicChoice = document.getElementById('musicSelect').value;
    if (musicChoice !== 'none' && MUSIC_TRACKS[musicChoice]) {
      try {
        statusText.innerText = 'Loading music...';
        const resp = await fetch(MUSIC_TRACKS[musicChoice]);
        if (resp.ok) {
          const buf = await resp.arrayBuffer();
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const audioBuffer = await audioCtx.decodeAudioData(buf);
          const dest = audioCtx.createMediaStreamDestination();
          audioSourceNode = audioCtx.createBufferSource();
          audioSourceNode.buffer = audioBuffer;
          audioSourceNode.loop = true;
          audioSourceNode.connect(dest);
          audioSourceNode.start();
          audioStream = dest.stream;
          // We'll stop audio source after the expected total duration
          setTimeout(() => {
            try { audioSourceNode.stop(); audioCtx.close(); } catch(e){}
          }, (expectedTotal + 1) * 1000);
        } else {
          console.warn('Music fetch failed', resp.status);
        }
      } catch(e) {
        console.warn('Music load error', e);
      }
    }

    // start capture stream & MediaRecorder
    const captureStream = canvas.captureStream(fps);
    if (audioStream) {
      audioStream.getAudioTracks().forEach(t => captureStream.addTrack(t));
    }

    // Try to find best mime
    let mime = 'video/mp4';
    if (!MediaRecorder.isTypeSupported(mime)) {
      // Try VP9/VP8 webm fallbacks
      if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) mime = 'video/webm;codecs=vp9';
      else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) mime = 'video/webm;codecs=vp8';
      else mime = 'video/webm';
    }

    statusText.innerText = `Recording using mime: ${mime}`;
    progressFill.style.width = '5%';

    const recorder = new MediaRecorder(captureStream, { mimeType: mime });
    const chunks = [];
    recorder.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
    recorder.onerror = (e) => { console.error('Recorder error', e); };
    recorder.onstart = () => { console.log('recorder started'); };
    recorder.onstop = async () => {
      progressFill.style.width = '95%';
      statusText.innerText = 'Finalizing video...';

      const blob = new Blob(chunks, { type: mime });
      let blobUrl = URL.createObjectURL(blob);
      outputVideo.src = blobUrl;
      previewPanel.style.display = 'block';

      const prefix = document.getElementById('filenamePrefix').value.trim() || 'eptonline_video';
      const fname = `${prefix}_${nowTimestamp()}`;
      const selectedConvert = document.getElementById('autoConvertMp4').checked;

      if (selectedConvert && mime.indexOf('webm') !== -1) {
        // attempt client-side transcode to mp4 via ffmpeg.wasm
        try {
          await convertWebmToMp4ClientSide(blob, `${fname}.mp4`);
          statusText.innerText = 'Conversion to MP4 completed client-side.';
        } catch (err) {
          console.warn('Client-side conversion failed', err);
          // fall back to webm download
          downloadLink.href = blobUrl;
          downloadLink.download = `${fname}.${mime.includes('mp4') ? 'mp4' : 'webm'}`;
        }
      } else {
        downloadLink.href = blobUrl;
        // set extension based on mime
        const ext = mime.includes('mp4') ? 'mp4' : 'webm';
        downloadLink.download = `${fname}.${ext}`;
      }

      // Post-checks: load metadata and compare
      runPostGenerationChecks(blob, expectedTotal, dims).catch(()=>{});
      progressFill.style.width = '100%';
      statusText.innerText = 'Done.';
    };

    // begin rendering frames and recording
    recorder.start(1000); // request data every second
    statusText.innerText = 'Recording started...';
    progressFill.style.width = '8%';

    // render timeline frames
    const timeline = [];
    if (addIntro) timeline.push({type:'intro', duration: introDur});
    for (const s of assets.slides) timeline.push({type:'slide', img: s.img, duration: s.duration});
    if (addOutro) timeline.push({type:'outro', duration: outroDur});

    let elapsed = 0;
    let timelineIndex = 0;
    const startTime = performance.now();

    function renderTick() {
      const now = performance.now();
      elapsed = (now - startTime) / 1000;
      // compute progress
      const progressPct = Math.min((elapsed / expectedTotal) * 100, 99);
      progressFill.style.width = progressPct + '%';
      statusText.innerText = `Rendering: ${elapsed.toFixed(1)}s / ${expectedTotal.toFixed(1)}s`;

      // find current segment
      let tPtr = 0;
      let curSeg = null;
      for (const seg of timeline) {
        if (elapsed >= tPtr && elapsed < tPtr + seg.duration) {
          curSeg = seg;
          break;
        }
        tPtr += seg.duration;
      }

      // If no segment (elapsed >= expectedTotal) then stop
      if (!curSeg) {
        // finish
        try { recorder.stop(); } catch(e){ console.warn(e); }
        return;
      }

      // Render according to segment
      if (curSeg.type === 'intro') {
        renderIntroFrame(ctx, canvas.width, canvas.height, preset);
      } else if (curSeg.type === 'outro') {
        renderOutroFrame(ctx, canvas.width, canvas.height, preset);
      } else if (curSeg.type === 'slide') {
        // Draw background
        ctx.fillStyle = document.getElementById('bgColor').value || '#000';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        drawImageCover(ctx, curSeg.img, canvas.width, canvas.height);
        drawLogoTopRight(ctx, canvas.width, canvas.height, assets.logo, 0.12);
        drawFooterSocialBar(ctx, canvas.width, canvas.height, preset);
      }

      // request next frame
      requestAnimationFrame(renderTick);
    }

    // kick off rendering loop
    requestAnimationFrame(renderTick);

    // Safety: force stop after slightly more than expected duration
    setTimeout(() => {
      if (recorder.state === 'recording') {
        try { recorder.stop(); } catch(e){ console.warn(e); }
      }
    }, (expectedTotal + 2) * 1000);

  } catch (err) {
    console.error('Generation error', err);
    alert('An error occurred: ' + (err.message || err));
    statusText.innerText = 'Error during generation.';
  }
}

/* ============ Post-generation checks ============ */

async function runPostGenerationChecks(blob, expectedDuration, dims) {
  return new Promise((resolve) => {
    const video = document.createElement('video');
    video.preload = 'metadata';
    video.onloadedmetadata = () => {
      URL.revokeObjectURL(video.src);
      const duration = video.duration;
      const checks = [];
      // duration tolerance
      const tol = 0.9; // allow small differences
      if (Math.abs(duration - expectedDuration) > 1.2) {
        checks.push(`Duration mismatch: expected ${expectedDuration.toFixed(1)}s, actual ${duration.toFixed(1)}s`);
      } else {
        checks.push(`Duration OK (${duration.toFixed(1)}s)`);
      }
      // resolution check
      const vw = video.videoWidth;
      const vh = video.videoHeight;
      if (vw !== dims.w || vh !== dims.h) {
        checks.push(`Resolution: expected ${dims.w}Ã—${dims.h}, actual ${vw}Ã—${vh} (player may scale; check source file).`);
      } else {
        checks.push(`Resolution OK (${vw}Ã—${vh})`);
      }
      const post = document.getElementById('postChecks');
      post.innerHTML = checks.map(c => `<div class="small-note">${c}</div>`).join('');
      resolve(true);
    };
    video.onerror = () => {
      resolve(false);
    };
    const url = URL.createObjectURL(blob);
    video.src = url;
  });
}

/* ============ Optional: ffmpeg.wasm conversion ============ */

// Note: This will fetch ffmpeg.wasm from CDN and run in the browser. It is heavy.
let ffmpegLoaded = false;
let ffmpegCore = null;
async function loadFFmpeg() {
  if (ffmpegLoaded) return ffmpegCore;
  statusText.innerText = 'Loading ffmpeg.wasm (this may take time)...';
  // Use @ffmpeg/ffmpeg via CDN
  const { createFFmpeg, fetchFile } = FFmpeg || window.FFmpeg || {};
  if (typeof createFFmpeg !== 'function') {
    // If not present, dynamically load the library
    await loadScript('https://unpkg.com/@ffmpeg/ffmpeg@0.11.1/dist/ffmpeg.min.js');
  }
  const ffmpegModule = createFFmpeg({ log: true });
  await ffmpegModule.load();
  ffmpegLoaded = true;
  ffmpegCore = { ffmpegModule, fetchFile: window.FFmpeg?.fetchFile || fetchFile };
  return ffmpegCore;
}

async function convertWebmToMp4ClientSide(webmBlob, outputFilename) {
  if (!window.createFFmpeg) {
    // load script
    await loadScript('https://unpkg.com/@ffmpeg/ffmpeg@0.11.1/dist/ffmpeg.min.js');
  }
  const { createFFmpeg, fetchFile } = window.FFmpeg;
  const ffmpeg = createFFmpeg({ log: true });
  await ffmpeg.load();
  statusText.innerText = 'Converting to MP4 (client-side)...';
  const inName = 'input.webm';
  const outName = 'out.mp4';
  ffmpeg.FS('writeFile', inName, await fetchFile(webmBlob));
  // Transcode with reasonable settings (fast preset)
  await ffmpeg.run('-i', inName, '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', outName);
  const data = ffmpeg.FS('readFile', outName);
  const convertedBlob = new Blob([data.buffer], { type: 'video/mp4' });
  const url = URL.createObjectURL(convertedBlob);
  downloadLink.href = url;
  downloadLink.download = outputFilename;
  outputVideo.src = url;
  statusText.innerText = 'MP4 conversion finished.';
  return true;
}

function loadScript(url) {
  return new Promise((resolve, reject) => {
    // Do not load twice
    if (document.querySelector(`script[src="${url}"]`)) return resolve();
    const s = document.createElement('script');
    s.src = url;
    s.onload = () => resolve();
    s.onerror = (e) => reject(e);
    document.head.appendChild(s);
  });
}

/* ============ Wire UI controls ============ */

document.getElementById('btnGenerate').addEventListener('click', async () => {
  // Basic pre-check: ensure playlist exists
  const preset = document.getElementById('downloadSelect').value;
  const dims = setCanvasSizeForPreset(preset);
  // calculate expected total
  const intro = document.getElementById('addIntro').checked ? Number(document.getElementById('introDuration').value || 2) : 0;
  const outro = document.getElementById('addOutro').checked ? Number(document.getElementById('outroDuration').value || 3) : 0;
  const slidesTotal = playlist.reduce((s,i)=>s + Number(i.duration||0), 0);
  const expectedTotal = intro + slidesTotal + outro;

  const v = validateBeforeGeneration(dims, expectedTotal);
  if (!v.ok) {
    // Show issues and ask confirm
    const proceed = confirm('The following issues were detected:\n\n' + v.errors.join('\n') + '\n\nProceed anyway?');
    if (!proceed) return;
  }

  // If user set autoConvertMp4 checked, ensure FFmpeg lib is available (will be loaded on demand in the flow).
  if (document.getElementById('autoConvertMp4').checked) {
    // warn about load time
    const ok = confirm('Client-side MP4 conversion will load a large wasm (ffmpeg.wasm) and may be slow. Continue?');
    if (!ok) return;
    // attempt to preload library (optional)
    try { await loadScript('https://unpkg.com/@ffmpeg/ffmpeg@0.11.1/dist/ffmpeg.min.js'); } catch(e) { console.warn('ffmpeg load prefetch failed', e); }
  }

  // disable UI until done
  btnGenerate.disabled = true;
  await startGenerationFlow();
  btnGenerate.disabled = false;
});

document.getElementById('btnPreviewCanvas').addEventListener('click', () => {
  // quick render of first slide or intro preview
  const preset = document.getElementById('downloadSelect').value;
  const dims = setCanvasSizeForPreset(preset);
  canvas.width = dims.w;
  canvas.height = dims.h;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const addIntro = document.getElementById('addIntro').checked;
  if (addIntro) {
    renderIntroFrame(ctx, canvas.width, canvas.height, preset);
  } else if (playlist.length > 0) {
    const src = playlist[0].file;
    loadImageFromSource(src).then(img => {
      if (!img) return alert('Cannot load preview image.');
      ctx.fillStyle = document.getElementById('bgColor').value || '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      drawImageCover(ctx, img, canvas.width, canvas.height);
      drawLogoTopRight(ctx, canvas.width, canvas.height, assets.logo, 0.12);
      drawFooterSocialBar(ctx, canvas.width, canvas.height, preset);
    });
  } else {
    alert('No slides to preview. Add images or enable Intro.');
  }
});

document.getElementById('btnClear').addEventListener('click', () => {
  if (!confirm('Clear all uploaded slides?')) return;
  playlist.forEach(p => URL.revokeObjectURL(p.thumbnailURL));
  playlist = [];
  renderPlaylist();
  previewPanel.style.display = 'none';
  statusText.innerText = '';
  progressFill.style.width = '0%';
});

btnConvertIfNeeded.addEventListener('click', async () => {
  // attempt to convert currently loaded video blob in outputVideo to mp4
  const src = outputVideo.src;
  if (!src) return alert('No generated video to convert.');
  // fetch blob
  try {
    const resp = await fetch(src);
    const blob = await resp.blob();
    const prefix = document.getElementById('filenamePrefix').value.trim() || 'eptonline_video';
    await convertWebmToMp4ClientSide(blob, `${prefix}_${nowTimestamp()}.mp4`);
    alert('Conversion finished (if succeeded, check Download button).');
  } catch (e) {
    console.error(e);
    alert('Conversion failed: ' + (e.message || e));
  }
});

/* Initialize playlist UI state */
renderPlaylist();

/* Optional: preload sample icons (non-blocking) */
(async function preloadIcons(){
  assets.icons.fb = await loadImageFromSource(ICONS.fb);
  assets.icons.ig = await loadImageFromSource(ICONS.ig);
  assets.icons.yt = await loadImageFromSource(ICONS.yt);
  assets.icons.tiktok = await loadImageFromSource(ICONS.tiktok);
})();

</script>
</body>
</html>
